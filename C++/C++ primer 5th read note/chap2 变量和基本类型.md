# 1. 基本内置类型
1. 类型可分为带符号和无符号，`C++`中`char`由编译器决定解释为`unsigned char`或者是`signed char`
2. 算数表达式中不要使用`char`和`bool`，由原因1可知，如果需要表示一个不大的变量，应该明确的写成`unsigned char`或者是`signed char`
3. 有符号和无符号数：
  - 不要在表达式中混合使用
  - `int`为例： 表达式中的如果包含有符号的，那么`int`就会转换成无符号的`int`参与运算
# 2.变量
1. 初始化
  C++已经支持很多种变量初始化的方式：
  ```C++
  int a = 0;
  int a = {0}; //列表初始化
  int a(0);
  int a{0};
  ```
  这些方式在C++中都是被支持的，其中，如果使用列表初始化，并且初始值有可能丢失的情况下（譬如涉及到类型转换），编译器会报错。
# 3. 复合类型
1. 引用
- 类型的别名
- 允许在一条语句中定义多个引用，但是每个引用必须以`&`修饰

2. 指针
- `void*`是一种特殊的指针类型，可以存放任意对象的地址
- 理解指向指针的引用`int*& p`.面对稍微复杂点的声明语句，可以**从右向左**阅读
# 4. `const`限定符
1. 默认情况下，`const`限定符只在文件内有效，当多个文件中出现了同名的`const`变量时，等同于在不用的文件中定义了独立的变量。
2. 需要在不同文件间共享的常量，那么无论是定义还是声明都加上`extern`
3. 初始化常量引用时可以使用任意表达式，只要该表达式可以转换成引用的类型即可
4. 常量指针：*在const之前；说明指针不可变，但是指针指向的值可以变   （**从右向左阅读**）
```C++
int errNum = 0;
int * const curErr = &errNum; //常量指针，指针不可变，常量的值可变
const int * curErr = &errNum; //指针常量，指针可变，常量的值不可变
```
5. 顶层`const` & 底层`const`
顶层`const`：指针本身是个常量
底层`const`：指针所指的对象是个常量
# 5. 处理类型
- `typedef:` 为类型取别名     `typedef double d`
- `using:`类似于`typedef`     `using d = double`
- `auto`:由初始值推断需要定义的变量的类型
- `decltype`:由表达式的类型推断出要定义的变量的类型，但是不使用该表达式的值来初始化变量




tips: 需要的时候再来补充基本语法
