# chap4 继承
1.  C#不支持私有继承，因此不需要在基类名字前面加上`public`或者`private`

2.  虚函数：
  - 将某个基类函数声明为`virtual`，就可以在任何派生类中重写该函数
  - 在派生类中重写函数的时候，需要使用`override`关键字显示声明     **区别于C++的地方**

3.  隐藏方法：
  如果基类和派生类都声明了相同的方法，但是不是虚函数的使用方式，需要注意避免，有可能会造成错误。

4.  调用函数的基类版本：
  C#可使用`base.<MethodName>()`来调用基类的任何方法
  
5.  抽象函数：
  - `abstract`，抽象函数本身也是虚拟的，但是不需要添加`virtual`来修饰，否则会报错
  - 类中包含抽象函数，该类也必须声明为抽象的
  - 抽象类不能实例化，抽象函数不能直接实现

6.  密封类和密封方法：
  - `sealed`

7.  接口：
  - 接口成员总是公有的

# chap5 泛型
1. 与C++的区别：
  对于C++而言，模板在实例化的时候，需要模板的源代码，但是泛型在C#中是一种内置的结构
2. 泛型类型可以实现泛型接口，也可以派生自一个类。但要求必须要重复接口的泛型类型或者必须指定基类的类型：
```C#
public class Base<T>
{
}
public class Derived<T>:Base<T>
{
}

//class
public class Derived<T>:Base<string>
{
}
```
3. 静态成员：
 泛型类的静态成员只能在类的一个实例中共享
 
 # chap6 数组
 1. Array 类
  (1)CreateInstance()创建数组
  (2)SetValue()\GetValue()
  (3)Clone()
    数组是引用类型，如果直接将两个数组赋值，将会得到两个引用。所以需要使用Clone将每个值进行赋值。如果数组中存储的是引用，使用Clone()也会将所有的引用赋值一遍。
  (4)Copy()
      Copy与Clone的区别在于，Copy必须要存在已知数组。
  (5)Sort()
  
2. 枚举
  (1)yield return:
    不需要重新开辟内存
  (2)foreach语句

3. 元组Tuple

# chap7 运算符和类型强制转换
1. checked & unchecked运算符：
  要不要执行类型检查
  
2. is 运算符：
  检查对象是否与特定的类型相兼容
  
3. as 运算符：
  用于执行引用类型的显示类型转换，如果类型兼容，则转换成功，如果类型不兼容，最后转换的结果为NULL
  
4. 可空类型：
  int?  bool?
  
5. 空合并运算符：
  ??
  



 
