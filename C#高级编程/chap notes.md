# chpa2 核心C#
  1. C# 中变量未初始化会当成一个错误来对待
  - 变量位于类或结构中，未显示初始化，创建这些变量时，默认的值就是0
  - 局部变量必须显示初始化
  
  2. `var`
  编译器根据变量的初始化值推断变量的类型
  
  3. 值类型 & 引用类型
  - 值类型： 存储在堆栈中
  - 引用类型： 存储在托管堆上
  类似于C++的引用。C#中所有数据类型都以与平台无关的方式进行定义
  
  4.预定义的引用类型：
  - `object`类型
    - `object`类型是所有类的父类型
    - `object`类实现了许多一般用途的基本方法
    
  - `string`类型
    - 引用类型，**待验证，在vs2010上验证的并不是引用类型**
  
  5. `foreach`
  - `foreach(var in vararry)`

# chap3 对象和类型
1. 属性
2. 类 & 结构
  - 类
    - 引用类型
  - 结构
    - 值类型
3. 弱引用
4. 部分类
  `partial`，将`partial`放在`class`，`struct`，`interface`前面
5. 静态类

# chap4 继承
1.  C#不支持私有继承，因此不需要在基类名字前面加上`public`或者`private`

2.  虚函数：
  - 将某个基类函数声明为`virtual`，就可以在任何派生类中重写该函数
  - 在派生类中重写函数的时候，需要使用`override`关键字显示声明     **区别于C++的地方**

3.  隐藏方法：
  如果基类和派生类都声明了相同的方法，但是不是虚函数的使用方式，需要注意避免，有可能会造成错误。

4.  调用函数的基类版本：
  C#可使用`base.<MethodName>()`来调用基类的任何方法
  
5.  抽象函数：
  - `abstract`，抽象函数本身也是虚拟的，但是不需要添加`virtual`来修饰，否则会报错
  - 类中包含抽象函数，该类也必须声明为抽象的
  - 抽象类不能实例化，抽象函数不能直接实现

6.  密封类和密封方法：
  - `sealed`

7.  接口：
  - 接口成员总是公有的

8. 
| 修饰符      | 应用于     | 说明     |
| ---------- | :-----------:  | :-----------: |
| public     | 所有类型或成员     | 任何代码均可访问     |
| ---------- | :-----------:  | :-----------: |
| protected     |类型和内嵌类型的所有成员     | 只有派生的类型能访问该项     |
| ---------- | :-----------:  | :-----------: |
| internal     | 所有类型或成员     | 只能在包含它的程序集中访问该项     |
| ---------- | :-----------:  | :-----------: |
| private     | 类型或内嵌类型的所有成员     | 只能在它所属的类型中访问该项     |
| ---------- | :-----------:  | :-----------: |
| protected internal     | 类型或内嵌类型的所有成员     | 只能在包含它的程序集和派生类型的任何代码中访问该项     |

# chap5 泛型
1. 与C++的区别：
  对于C++而言，模板在实例化的时候，需要模板的源代码，但是泛型在C#中是一种内置的结构
2. 泛型类型可以实现泛型接口，也可以派生自一个类。但要求必须要重复接口的泛型类型或者必须指定基类的类型：
```C#
public class Base<T>
{
}
public class Derived<T>:Base<T>
{
}

//class
public class Derived<T>:Base<string>
{
}
```
3. 静态成员：
 泛型类的静态成员只能在类的一个实例中共享
 
 # chap6 数组
 1. Array 类
  (1)CreateInstance()创建数组
  (2)SetValue()\GetValue()
  (3)Clone()
    数组是引用类型，如果直接将两个数组赋值，将会得到两个引用。所以需要使用Clone将每个值进行赋值。如果数组中存储的是引用，使用Clone()也会将所有的引用赋值一遍。
  (4)Copy()
      Copy与Clone的区别在于，Copy必须要存在已知数组。
  (5)Sort()
  
2. 枚举
  (1)yield return:
    不需要重新开辟内存
  (2)foreach语句

3. 元组Tuple

# chap7 运算符和类型强制转换
1. checked & unchecked运算符：
  要不要执行类型检查
  
2. is 运算符：
  检查对象是否与特定的类型相兼容
  
3. as 运算符：
  用于执行引用类型的显示类型转换，如果类型兼容，则转换成功，如果类型不兼容，最后转换的结果为NULL
  
4. 可空类型：
  int?  bool?
  
5. 空合并运算符：
  ??
  
# chap8 委托，lambda表达式和事件
1. 委托
(1)定义：
  `delegate`： `delegate void IntMethodInvoker(int x)`
  
(2)使用：
  




 
